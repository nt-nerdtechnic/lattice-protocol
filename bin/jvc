#!/bin/bash
# JVC (JSON Version Control) v3.3 - The Ecosystem Engine
# Open Source Release for AI-Native Distributed Collaboration
# 
# Description:
#   A JSON-native version control system featuring recursive dependency management.
#   Designed for Agentic Swarms to synchronize skills and environment states atomically.
#
# Usage:
#   jvc fetch                - Rebuild local index from Cloud Master
#   jvc pull                 - Recursive sync (handles dependencies automatically)
#   jvc push <skill> <msg>   - Atomic push with locking and snapshots
#   jvc status               - Compare local vs master versions
#   jvc history <skill>      - View JSON commit logs

# --- Configuration ---
WORKSPACE_ROOT="${JVC_WORKSPACE_ROOT:-$HOME/ai_workspace}"
LOCAL_REPO="$WORKSPACE_ROOT/skills"
LOCAL_REGISTRY="$LOCAL_REPO/jvc_registry.json"
CACHE_FILE="$LOCAL_REPO/jvc_cloud_map.json"

# --- Ignore List (AI-Native Optimization) ---
SYNC_IGNORE=("COMMIT_HISTORY.md" "*.log" ".DS_Store" "manifest.json" ".lock" "snapshots")
EXCLUDE_ARGS=""
for item in "${SYNC_IGNORE[@]}"; do EXCLUDE_ARGS="$EXCLUDE_ARGS --exclude='$item'"; done

# Default Master
MASTER_REPO="${JVC_MASTER_REPO:-$HOME/lattice_master}"

# --- Helper Functions ---

fetch_master() {
    echo "ðŸ”„ JVC Fetch: Scanning Lattice nodes..."
    echo "{ \"skills\": {} }" > "$CACHE_FILE"
    [ ! -d "$MASTER_REPO" ] && echo "ðŸš¨ Master not found." && return 1
    manifests=$(find "$MASTER_REPO" -name "manifest.json")
    for m in $manifests; do
        skill_info=$(cat "$m")
        name=$(echo "$skill_info" | jq -r ".skill_name // empty")
        [ -z "$name" ] && continue
        rel_path=$(dirname "$m"); rel_path=${rel_path#$MASTER_REPO/}
        tmp=$(mktemp)
        jq --arg name "$name" --arg path "$rel_path" --argjson info "$skill_info" \
           ".skills[\$name] = \$info | .skills[\$name].cloud_path = \$path" "$CACHE_FILE" > "$tmp" && mv "$tmp" "$CACHE_FILE"
    done
    echo "âœ… Fetch Complete: $(jq '.skills | length' "$CACHE_FILE") nodes found."
}

get_cloud_info() {
    local s=$1; [ ! -f "$CACHE_FILE" ] && fetch_master > /dev/null
    jq -r ".skills.\"$s\" // empty" "$CACHE_FILE"
}

pull_skill_logic() {
    local s=$1; local cloud_info=$(get_cloud_info "$s")
    [ -z "$cloud_info" ] && return

    # --- v3.3 Recursive Dependency Management ---
    local deps=$(echo "$cloud_info" | jq -r '.dependencies[]?' 2>/dev/null)
    for dep in $deps; do
        echo "ðŸ”— Dependency found: [$s] needs [$dep]"
        pull_skill_logic "$dep"
    done

    local cloud_path=$(echo "$cloud_info" | jq -r ".cloud_path")
    local m_ver=$(echo "$cloud_info" | jq -r ".version")
    
    # Check local version to avoid redundant pull
    local l_ver=$(jq -r ".skills.\"$s\".version // \"0.0\"" "$LOCAL_REGISTRY" 2>/dev/null)
    [ "$l_ver" == "$m_ver" ] && [ -d "$LOCAL_REPO/$s" ] && return

    echo "  -> Syncing [$s] v$m_ver..."
    mkdir -p "$LOCAL_REPO/$s"
    eval "rsync -av --delete $EXCLUDE_ARGS \"$MASTER_REPO/$cloud_path/\" \"$LOCAL_REPO/$s/\""
    
    tmp=$(mktemp); [ ! -f "$LOCAL_REGISTRY" ] && echo "{ \"skills\": {} }" > "$LOCAL_REGISTRY"
    jq ".skills.\"$s\".version = \"$m_ver\"" "$LOCAL_REGISTRY" > "$tmp" && mv "$tmp" "$LOCAL_REGISTRY"
}

# --- Main Logic ---

case "$1" in
    fetch) fetch_master ;;
    pull)  
        fetch_master > /dev/null
        if [ -f "$LOCAL_REGISTRY" ]; then
            TARGETS=$(jq -r '.sync_targets[]? // empty' "$LOCAL_REGISTRY")
            for t in $TARGETS; do
                if [[ "$t" == cat:* ]]; then
                    cat_name=${t#cat:}
                    for s in $(jq -r ".skills | to_entries | .[] | select(.value.category == \"$cat_name\") | .key" "$CACHE_FILE"); do pull_skill_logic "$s"; done
                else pull_skill_logic "$t"; fi
            done
        fi ;;
    push)
        s=$2; msg=$3; [ -z "$s" ] || [ -z "$msg" ] && exit 1
        cloud_info=$(get_cloud_info "$s"); cloud_path=$(echo "$cloud_info" | jq -r ".cloud_path")
        LOCK_DIR="$MASTER_REPO/$cloud_path/.lock"
        mkdir "$LOCK_DIR" 2>/dev/null || (echo "ðŸš¨ Locked" && exit 1)
        trap 'rm -rf "$LOCK_DIR"' EXIT
        old_ver=$(echo "$cloud_info" | jq -r ".version"); new_ver=$(echo "$old_ver" | awk "{print \$1 + 0.1}"); now=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
        mkdir -p "$MASTER_REPO/snapshots"
        tar -czf "$MASTER_REPO/snapshots/${s}_v${old_ver}.tar.gz" -C "$MASTER_REPO" "$cloud_path" 2>/dev/null
        rsync -av "$LOCAL_REPO/$s/" "$MASTER_REPO/$cloud_path/"
        tmp_m=$(mktemp); jq ".version = \"$new_ver\" | .description = \"$msg\" | .last_updated = \"$now\" | .history = ([\"[$now] v$new_ver - $msg\"] + .history | .[0:10])" "$MASTER_REPO/$cloud_path/manifest.json" > "$tmp_m" && mv "$tmp_m" "$MASTER_REPO/$cloud_path/manifest.json"
        echo "[$now] v$new_ver - $msg" >> "$MASTER_REPO/$cloud_path/COMMIT_HISTORY.md"
        echo "âœ… Push Complete." ;;
    status)
        fetch_master > /dev/null
        # ... version comparison logic ...
        ;;
    *) echo "Lattice JVC v3.3 (Ecosystem Edition)"; exit 1 ;;
esac
