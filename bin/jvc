#!/bin/bash
# JVC (JSON Version Control) - AI-Native Distributed Sync (v3.4 Ecosystem Version)
# Created for NT AI Team by Marketing AI & Antigravity

WORKSPACE_ROOT="$HOME/clawd"
LOCAL_REPO="$WORKSPACE_ROOT/skills"
CONFIG_FILE="$LOCAL_REPO/skill-sync-manager/config.json"
REGISTRY_FILE="$LOCAL_REPO/skill-sync-manager/registry.json"
GLOBAL_IGNORE="$LOCAL_REPO/skill-sync-manager/.jvcignore"

# é è¨­æ’é™¤åå–® (Hardcoded safety)
DEFAULT_IGNORE=("COMMIT_HISTORY.md" "*.log" ".DS_Store" ".SynologyWorkingDirectory" "manifest.json" ".lock" "local_registry.json" "config.json" "registry.json" "cloud_map_cache.json" ".jvcignore")

# å–å¾—æ’é™¤åƒæ•¸çš„å‡½å¼
get_exclude_args() {
    local s=$1
    local args=""
    
    # 1. é è¨­æ’é™¤
    for item in "${DEFAULT_IGNORE[@]}"; do args="$args --exclude=$item"; done
    
    # 2. å…¨å±€ .jvcignore (ä½æ–¼ skill-sync-manager)
    if [ -f "$GLOBAL_IGNORE" ]; then
        args="$args --exclude-from=$GLOBAL_IGNORE"
    fi
    
    # 3. æœ¬åœ°æŠ€èƒ½ç‰¹å®š .jvcignore
    if [ -n "$s" ] && [ -f "$LOCAL_REPO/$s/.jvcignore" ]; then
        args="$args --exclude-from=$LOCAL_REPO/$s/.jvcignore"
    fi
    
    # 4. æ ¹ç›®éŒ„ .jvcignore
    if [ -f "$WORKSPACE_ROOT/.jvcignore" ]; then
        args="$args --exclude-from=$WORKSPACE_ROOT/.jvcignore"
    fi
    
    echo "$args"
}

# å–å¾—æœ¬åœ°é…ç½®
if [ -f "$CONFIG_FILE" ]; then
    MASTER_REPO=$(jq -r '.master_repo_path // empty' "$CONFIG_FILE")
    SYNC_TARGETS=$(jq -r '.sync_targets[]' "$CONFIG_FILE" 2>/dev/null | tr '\n' ' ')
else
    # é™ç´šç›¸å®¹ (Migration Check)
    OLD_REGISTRY="$LOCAL_REPO/skill-sync-manager/local_registry.json"
    if [ -f "$OLD_REGISTRY" ]; then
        MASTER_REPO=$(jq -r '.master_repo_path // empty' "$OLD_REGISTRY")
        SYNC_TARGETS=$(jq -r '.sync_targets[]' "$OLD_REGISTRY" 2>/dev/null | tr '\n' ' ')
    fi
fi

DEFAULT_MASTER_REPO="$HOME/NT_SKILL"
MASTER_REPO=${MASTER_REPO:-$DEFAULT_MASTER_REPO}

usage() {
    echo "===================================================="
    echo "       JVC (JSON Version Control) - v3.4            "
    echo "===================================================="
    echo ""
    echo "Commands (AI-Native v3.4):"
    echo "  fetch                - æƒæé›²ç«¯ manifest é‡å»º JVC åœ°åœ–"
    echo "  pull                 - åŸ·è¡ŒåŒæ­¥ (è‡ªå‹•è™•ç†ä¾è³´é—œä¿‚)"
    echo "  push <skill> <msg>   - æ™ºæ…§æ¨é€ (Lock + Snapshot + Sync)"
    echo "  history <skill>      - ç›´æ¥è®€å–é›²ç«¯ JVC æ­·å²ç´€éŒ„"
    echo "  status               - æ¯”è¼ƒæœ¬åœ°èˆ‡ JVC Master å·®ç•°"
    echo "  tree                 - ç”Ÿæˆæœ¬åœ° SKILL_TREE.md"
    echo ""
    echo "Environment Settings:"
    echo "  Config: $CONFIG_FILE"
    echo "  Registry: $REGISTRY_FILE"
    echo "  Cloud Master: $MASTER_REPO"
    exit 1
}

fetch_master() {
    echo "ğŸ”„ JVC Fetch: æ­£åœ¨æƒæé›²ç«¯ manifest ç¯€é»..."
    MAP_FILE="$LOCAL_REPO/skill-sync-manager/cloud_map_cache.json"
    echo "{ \"skills\": {} }" > "$MAP_FILE"
    
    manifests=$(find "$MASTER_REPO" -name "manifest.json")
    for m in $manifests; do
        skill_info=$(cat "$m")
        name=$(echo "$skill_info" | jq -r ".skill_name")
        full_dir=$(dirname "$m")
        rel_path=${full_dir#$MASTER_REPO/}
        
        tmp=$(mktemp)
        jq --arg name "$name" --arg path "$rel_path" --argjson info "$skill_info" \
           ".skills[\$name] = \$info | .skills[\$name].cloud_path = \$path" "$MAP_FILE" > "$tmp" && mv "$tmp" "$MAP_FILE"
    done
    echo "âœ… Fetch å®Œæˆï¼šåµæ¸¬åˆ° $(jq '.skills | length' "$MAP_FILE") å€‹æœ‰æ•ˆç¯€é»ã€‚"
}

get_cloud_info() {
    local s=$1; local cache="$LOCAL_REPO/skill-sync-manager/cloud_map_cache.json"
    [ ! -f "$cache" ] && fetch_master > /dev/null
    jq -r ".skills.\"$s\" // empty" "$cache"
}

get_local_version() {
    local s=$1
    if [ -f "$REGISTRY_FILE" ]; then
        jq -r ".skills.\"$s\".version // \"0.0\"" "$REGISTRY_FILE"
    elif [ -f "$LOCAL_REPO/skill-sync-manager/local_registry.json" ]; then
        jq -r ".skills.\"$s\".version // \"0.0\"" "$LOCAL_REPO/skill-sync-manager/local_registry.json"
    else
        echo "0.0"
    fi
}

update_local_version() {
    local s=$1; local ver=$2
    [ ! -f "$REGISTRY_FILE" ] && echo "{ \"skills\": {} }" > "$REGISTRY_FILE"
    tmp=$(mktemp)
    jq ".skills.\"$s\".version = \"$ver\"" "$REGISTRY_FILE" > "$tmp" && mv "$tmp" "$REGISTRY_FILE"
}

check_skill_status() {
    local s=$1; local cloud_info=$(get_cloud_info "$s")
    if [ -z "$cloud_info" ]; then echo "â“ JVC æ‰¾ä¸åˆ°æŠ€èƒ½: [$s]"; return; fi
    
    local m_ver=$(echo "$cloud_info" | jq -r ".version")
    local l_ver=$(get_local_version "$s")
    local cloud_path=$(echo "$cloud_info" | jq -r ".cloud_path")
    local EXCLUDE_ARGS=$(get_exclude_args "$s")
    
    # ä½¿ç”¨æ›´åŠ ç²¾ç¢ºçš„ rsync æ¯”å°é‚è¼¯
    local diff_check=$(rsync -ani $EXCLUDE_ARGS "$MASTER_REPO/$cloud_path/" "$LOCAL_REPO/$s/" 2>/dev/null | grep -E '^>f|^<f|^.f' | wc -l | xargs)
    
    if [[ "$l_ver" < "$m_ver" ]]; then echo "ğŸ”¼ å¯æ›´æ–°ï¼š[$s] (v$l_ver -> v$m_ver)";
    elif [ "$m_ver" == "$l_ver" ] && [ "$diff_check" -gt 0 ]; then echo "ğŸš¨ å…§å®¹è¡çªï¼š[$s]";
    elif [[ "$l_ver" > "$m_ver" ]]; then echo "ğŸ†• æœ¬åœ°è¼ƒæ–°ï¼š[$s] (v$l_ver > v$m_ver)";
    else echo "âœ… æœ€æ–°ï¼š[$s] (v$l_ver)"; fi
}

pull_skill_logic() {
    local s=$1; local cloud_info=$(get_cloud_info "$s")
    [ -z "$cloud_info" ] && return
    
    # --- v3.3 ä¾è³´ç®¡ç†é‚è¼¯ ---
    local deps=$(echo "$cloud_info" | jq -r '.dependencies[]?' 2>/dev/null)
    for dep in $deps; do
        echo "ğŸ”— åµæ¸¬åˆ°ä¾è³´ï¼š[$s] éœ€è¦ [$dep]"
        pull_skill_logic "$dep"
    done

    local cloud_path=$(echo "$cloud_info" | jq -r ".cloud_path")
    local m_ver=$(echo "$cloud_info" | jq -r ".version")
    local l_ver=$(get_local_version "$s")
    
    # æª¢æŸ¥æ˜¯å¦å·²ç¶“æ˜¯æœ€æ–°ï¼Œé¿å…é‡è¤‡æ‹‰å–
    if [ "$l_ver" == "$m_ver" ] && [ -d "$LOCAL_REPO/$s" ]; then
        return
    fi

    echo "  -> åŒæ­¥ JVC ç¯€é» [$s] (v$m_ver)..."
    mkdir -p "$LOCAL_REPO/$s"
    local EXCLUDE_ARGS=$(get_exclude_args "$s")
    eval "rsync -av --delete $EXCLUDE_ARGS \"$MASTER_REPO/$cloud_path/\" \"$LOCAL_REPO/$s/\""
    
    update_local_version "$s" "$m_ver"

    # [Hook] Post-Pull
    if [ -f "$LOCAL_REPO/$s/scripts/post_pull.sh" ]; then
        echo "ğŸª  åŸ·è¡Œ Post-Pull Hook..."
        bash "$LOCAL_REPO/$s/scripts/post_pull.sh"
    fi
}

pull_sync() {
    [ -z "$SYNC_TARGETS" ] && echo "ğŸš¨ éŒ¯èª¤ï¼šå°šæœªè¨­å®šåŒæ­¥ç›®æ¨™" && exit 1
    echo "â³ æ­£åœ¨å•Ÿå‹• JVC åŒæ­¥ (è™•ç†ä¾è³´ä¸­)..."
    for t in $SYNC_TARGETS; do
        if [[ "$t" == cat:* ]]; then
            cat_name=${t#cat:}; cache="$LOCAL_REPO/skill-sync-manager/cloud_map_cache.json"
            SKILLS=$(jq -r ".skills | to_entries | .[] | select(.value.category == \"$cat_name\") | .key" "$cache")
            for s in $SKILLS; do pull_skill_logic "$s"; done
        else pull_skill_logic "$t"; fi
    done
    echo "âœ… åŒæ­¥ä½œæ¥­å®Œæˆã€‚"
}

push_skill() {
    local s=$1; local msg=$2; [ -z "$s" ] || [ -z "$msg" ] && echo "ç”¨æ³•: push <skill> <msg>" && exit 1
    local cloud_info=$(get_cloud_info "$s")
    
    # [Hook] Pre-Push
    if [ -f "$LOCAL_REPO/$s/scripts/pre_push.sh" ]; then
        echo "ğŸª  åŸ·è¡Œ Pre-Push Hook..."
        bash "$LOCAL_REPO/$s/scripts/pre_push.sh" || { echo "âŒ Pre-Push Hook å¤±æ•—ï¼Œä¸­æ­¢æ¨é€ã€‚"; exit 1; }
    fi
    [ -z "$cloud_info" ] && echo "âŒ éŒ¯èª¤ï¼šJVC æ‰¾ä¸åˆ°æ­¤æŠ€èƒ½" && exit 1
    local cloud_path=$(echo "$cloud_info" | jq -r ".cloud_path")
    local LOCK_DIR="$MASTER_REPO/$cloud_path/.lock"
    
    echo "ğŸ”’ ç²å– JVC [$s] é–..."
    if ! mkdir "$LOCK_DIR" 2>/dev/null; then 
        # Soft Unlock Check
        if [ -d "$LOCK_DIR" ]; then
            now_ts=$(date +%s)
            # macOS compatible stat
            lock_ts=$(stat -f %m "$LOCK_DIR")
            age=$((now_ts - lock_ts))
            if [ "$age" -gt 600 ]; then
                echo "âš ï¸ åµæ¸¬åˆ°éæœŸé–å®š (${age}s > 600s)ï¼ŒåŸ·è¡Œè»Ÿè§£é– (Soft Unlock)..."
                rm -rf "$LOCK_DIR"
                # Retry lock
                if ! mkdir "$LOCK_DIR" 2>/dev/null; then
                    echo "ğŸš¨ è»Ÿè§£é–å¾Œé–å®šä»å¤±æ•—ï¼Œè«‹æ‰‹å‹•æª¢æŸ¥ã€‚" && exit 1
                fi
            else
                echo "ğŸš¨ é–å®šå¤±æ•—ï¼šè©²ç¯€é»æ­£è¢«ä½”ç”¨ (é–å®šæ™‚é–“: ${age}s)ã€‚" && exit 1
            fi
        else
            echo "ğŸš¨ é–å®šå¤±æ•—ï¼šæœªçŸ¥çš„é–å®šç‹€æ…‹ã€‚" && exit 1
        fi
    fi
    
    trap 'rm -rf "$LOCK_DIR"' EXIT

    local old_ver=$(echo "$cloud_info" | jq -r ".version")
    local new_ver=$(echo "$old_ver" | awk "{print \$1 + 0.1}")
    local now=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
    
    mkdir -p "$MASTER_REPO/snapshots"
    tar -czf "$MASTER_REPO/snapshots/${s}_v${old_ver}.tar.gz" -C "$MASTER_REPO" "$cloud_path" 2>/dev/null
    
    echo "ğŸš€ æ¨é€ [$s] v$new_ver åˆ° JVC é›²ç«¯..."
    [ -f "$LOCAL_REPO/$s/SKILL.md" ] && sed -i '' "s/version: .*/version: $new_ver/" "$LOCAL_REPO/$s/SKILL.md"
    
    local EXCLUDE_ARGS=$(get_exclude_args "$s")
    eval "rsync -av $EXCLUDE_ARGS \"$LOCAL_REPO/$s/\" \"$MASTER_REPO/$cloud_path/\""
    
    local hist_msg="[$now] v$new_ver - $msg"; tmp_m=$(mktemp)
    jq ".version = \"$new_ver\" | .description = \"$msg\" | .last_updated = \"$now\" | .history = ([\"$hist_msg\"] + .history | .[0:10])" "$MASTER_REPO/$cloud_path/manifest.json" > "$tmp_m" && mv "$tmp_m" "$MASTER_REPO/$cloud_path/manifest.json"
    echo "$hist_msg" >> "$MASTER_REPO/$cloud_path/COMMIT_HISTORY.md"
    
    update_local_version "$s" "$new_ver"
    echo "âœ… JVC æ¨é€å®Œæˆï¼"
}

case "$1" in
    fetch) fetch_master ;;
    status) fetch_master > /dev/null; echo "--- JVC åŒæ­¥ç‹€æ…‹ ---";
        for t in $SYNC_TARGETS; do
            if [[ "$t" == cat:* ]]; then
                cat_name=${t#cat:}; cache="$LOCAL_REPO/skill-sync-manager/cloud_map_cache.json"
                SKILLS=$(jq -r ".skills | to_entries | .[] | select(.value.category == \"$cat_name\") | .key" "$cache")
                for s in $SKILLS; do check_skill_status "$s"; done
            else check_skill_status "$t"; fi
        done ;;
    pull) fetch_master > /dev/null; pull_sync ;;
    push) push_skill "$2" "$3" ;;
    history) info=$(get_cloud_info "$2"); [ -n "$info" ] && echo "$info" | jq -r '.history[]' || echo "ç„¡ç´€éŒ„" ;;
    *) usage ;;
esac
